#ifndef PCD_PROCESSING_CLASS_H
#define PCD_PROCESSING_CLASS_H

#include <cv_bridge/cv_bridge.h>
#include <image_transport/image_transport.h>
#include <masks_msgs/maskID.h>
#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <message_filters/sync_policies/exact_time.h>
#include <message_filters/synchronizer.h>
#include <ros/console.h>
#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/image_encodings.h>
#include <std_msgs/Char.h>
#include <tf/transform_listener.h>

#include <algorithm>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
// PCL specific includes
#include <pcl/ModelCoefficients.h>
#include <pcl/common/common.h>
#include <pcl/features/normal_3d.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/filter.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/io/pcd_io.h>
#include <pcl/kdtree/kdtree.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl_conversions/pcl_conversions.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>

/**
 * @brief Class pcd_processing: Processes RGB-D point clouds using 2D masks
 * generated by Segment Anything from Meta.
 */
class pcd_processing {
 public:
  // Alias:
  typedef pcl::PointXYZRGB point;  // Point Type (vector type)
  typedef pcl::PointCloud<pcl::PointXYZRGB>
      cloud;  // PointCloud Type (cloud vector type)
  typedef pcl::PointCloud<pcl::PointXYZRGB>::Ptr
      cloudPtr;  // Cloud Pointer Type

  /**
   * @brief Constructor for pcd_processing class
   *
   * @param nh_ ROS NodeHandle
   */
  pcd_processing(ros::NodeHandle &nh_);
  ~pcd_processing() {}

  /**
   * @brief Called periodically to update the pcd_processing object
   *
   * @param time Current ROS time
   */
  void update(const ros::Time &time);

 private:
  struct singlemask {
    int maskid;
    Eigen::Matrix<int64_t, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>
        segmentation;
    int area;
    std::vector<int32_t> bbox;
  };

  /**
   * @brief Preprocess the incoming raw point cloud, subsample and filter it.
   *
   * @param input Raw point cloud data
   * @param output Filtered and subsampled cloud data
   * @return true on success
   * @return false on failure
   */
  bool raw_cloud_preprocessing(cloudPtr &input, cloudPtr &output);

  /**
   * @brief Cut the point cloud using masks generated from SAM
   *
   * @param input Preprocessed point cloud
   * @param masks Masks from SAM
   * @param objects Objects cut from point cloud
   * @param background Background points cut from point cloud
   * @return true on success
   * @return false on failure
   */
  bool cut_point_cloud(cloudPtr &input, const std::vector<singlemask> &masks,
                       cloudPtr &objects, cloudPtr &background);

  /**
   * @brief Segment plane from the point cloud
   *
   * @param input Objects cut from point cloud
   * @return true on success
   * @return false on failure
   */
  bool segment_plane(cloudPtr &input);

  /**
   * @brief Callback function for new point cloud subscriber
   *
   * @param msg Point cloud message
   */
  void cloudCallback(const sensor_msgs::PointCloud2ConstPtr &msg);

  /**
   * @brief Callback function for new masks subscriber
   *
   * @param msg Masks message
   */
  void masksCallback(const masks_msgs::maskID::Ptr &msg);

  /**
   * @brief Count the number of ones in a matrix
   *
   * @param matrix Input matrix
   * @return Number of ones in the matrix
   */
  int countOnes(const Eigen::Matrix<int64_t, Eigen::Dynamic, Eigen::Dynamic,
                                    Eigen::RowMajor> &matrix);

  // Private variables
  std::string pointcloud_topic_;  //!< Topic name for point cloud data
  std::string base_frame_;        //!< Base frame for transformations
  bool is_cloud_updated;  //!< Flag indicating if a new point cloud is received
  bool enable_metrics_;   //!< Flag to enable or disable metrics logging

  ros::NodeHandle nh;                 //!< ROS NodeHandle
  ros::Subscriber point_cloud_sub_;   //!< Subscriber to the PointCloud data
  ros::Publisher objects_cloud_pub_;  //!< Publisher for objects point cloud
  ros::Publisher
      background_cloud_pub_;           //!< Publisher for background point cloud
  ros::Subscriber masks_sub_;          //!< Subscriber to the masks data
  ros::Publisher objects_marker_pub_;  //!< Publisher for objects marker
  cloudPtr raw_cloud_;                 //!< Internal raw point cloud
  cloudPtr preprocessed_cloud_;        //!< Internal preprocessed cloud
  cloudPtr objects_cloud_;             //!< Internal objects point cloud
  cloudPtr background_cloud_;          //!< Internal background point cloud
  masks_msgs::maskID::Ptr
      latest_maskID_msg_;              //!< Internal latest maskID message
  sensor_msgs::PointCloud2 cloudmsg_;  //!< Message to store point cloud data
  visualization_msgs::MarkerArray objects_marker_;  //!< Objects marker message

  std::vector<singlemask> processed_masks_;  //!< Internal processed masks

  /**
   * @brief Process maskID message to extract masks
   *
   * @param maskID MaskID message
   * @return Vector of processed masks
   */
  std::vector<singlemask> maskID_msg_processing(
      const masks_msgs::maskID::Ptr &maskID);

  // Transformation
  tf::TransformListener
      tf_listener_;  //!< Access ROS tf tree to get frame transformations
};

#endif